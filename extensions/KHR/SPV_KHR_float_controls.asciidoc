SPV_KHR_float_controls
======================

Name Strings
------------

SPV_KHR_float_controls

Contact
-------

See *Issues* list in the Khronos SPIRV-Headers repository:
https://github.com/KhronosGroup/SPIRV-Headers

Contributors
------------

- Alexander Galazin, Arm
- Neil Henning, AMD
- Jeff Bolz, NVIDIA
- John Kessenich, Google 
- Ruihao Zhang, Qualcomm

Notice
------

Copyright (c) 2016-2018 The Khronos Group Inc. Copyright terms at
http://www.khronos.org/registry/speccopyright.html

Status
------

- Complete
- Approved by the SPIR Working Group: 2018-09-05
- Ratified by Khronos: 2018-10-26

Version
-------

[width="40%",cols="25,25"]
|========================================
| Last Modified Date | 2018-09-06
| Revision           | 1
|========================================

Dependencies
------------

This extension is written against the SPIR-V Specification,
Version 1.3 Revision 1.

This extension requires SPIR-V 1.0.

Overview
--------

This extension provides new execution modes to control floating-point
computations by overriding an implementationâ€™s default behavior for
rounding modes, denormals, signed zero, and infinities.

Extension Name
--------------

To use this extension within a SPIR-V module, the following
*OpExtension* must be present in the module:

----
OpExtension "SPV_KHR_float_controls"
----

Modifications to the SPIR-V Specification, Version 1.3
------------------------------------------------------

Modify Section 3.6, Execution Mode, adding the following rows to the Execution Mode table: ::
+
--
[options="header"]
|====
2+^| Execution mode ^| Enabling Capabilities ^| Extra Operands
| 4459 | *DenormPreserve* +
Any denormalized value input into a shader or potentially generated by
any instruction in a shader must be preserved.
Denormalized values obtained via unpacking an integer into a vector of
values with smaller bit width and interpreting those values as
floating-point numbers must be preserved.
Only affects instructions operating on
a scalar or a composite type derived from a scalar floating-point type
defined by the extra operand of <<OpExecutionMode, *OpExecutionMode*>>. | *DenormPreserve*  | _<<Literal_Number, Literal Number>>_ + 
_Scalar Floating-Point Type Bit Width_
| 4460 | *DenormFlushToZero* + 
Any denormalized value input into a shader or potentially generated by
any instruction in a shader must be flushed to zero.
Denormalized values obtained via unpacking an integer into a vector of
values with smaller bit width and interpreting those values as
floating-point numbers must be flushed.
Only affects instructions operating on
a scalar or a composite type derived from a scalar floating-point type
defined by the extra operand of <<OpExecutionMode, *OpExecutionMode*>>.  | *DenormFlushToZero*  | _<<Literal_Number, Literal Number>>_ +
_Scalar Floating-Point Type Bit Width_
| 4461 | *SignedZeroInfNanPreserve* +
The implementation must not perform optimizations on floating-point instructions
that do not preserve sign of a zero, or assume that operands and results are
not NaNs or infinities.
Bit patterns for NaNs might not be preserved.
Only affects instructions operating on
a scalar or a composite type derived from a scalar floating-point type
defined by the extra operand of <<OpExecutionMode, *OpExecutionMode*>>.  | *SignedZeroInfNanPreserve*  | _<<Literal_Number, Literal Number>>_ + 
_Scalar Floating-Point Type Bit Width_
| 4462 | *RoundingModeRTE* +
The default rounding mode for floating-point arithmetic and conversions instructions
must be round-to-nearest-even.
Only affects instructions operating on
a scalar or a composite type derived from a scalar floating-point type
defined by the extra operand of <<OpExecutionMode, *OpExecutionMode*>>.
If an instruction is decorated with *FPRoundingMode* or defines a rounding mode in its description,
that rounding mode is applied and *RoundingModeRTE* is ignored. | *RoundingModeRTE*  | _<<Literal_Number, Literal Number>>_ + 
_Scalar Floating-Point Type Bit Width_
| 4463 | *RoundingModeRTZ* +
The default rounding mode for floating-point arithmetic and conversions instructions
must be round-towards-zero.
Only affects instructions operating on
a scalar or a composite type derived from a scalar floating-point type
defined by the extra operand of <<OpExecutionMode, *OpExecutionMode*>>.
If an instruction is decorated with *FPRoundingMode* or defines a rounding mode in its description,
that rounding mode is applied and *RoundingModeRTZ* is ignored. | *RoundingModeRTZ*  | _<<Literal_Number, Literal Number>>_ + 
_Scalar Floating-Point Type Bit Width_
|====
--

Modify Section 3.31, Capability, adding the following rows to the Capability table: ::
+
--
[options="header"]
|====
2+^| Capability ^| Implicitly Declares ^| Enabled by Extension
| 4464 | *DenormPreserve* +
Uses the *DenormPreserve* <<Execution_Mode,Execution Mode>>           | | *SPV_KHR_float_controls*
| 4465 | *DenormFlushToZero* +
Uses the *DenormFlushToZero* <<Execution_Mode,Execution Mode>>        | | *SPV_KHR_float_controls*
| 4466 | *SignedZeroInfNanPreserve* +
Uses the *SignedZeroInfNanPreserve* <<Execution_Mode,Execution Mode>> | | *SPV_KHR_float_controls*
| 4467 | *RoundingModeRTE* +
Uses the *RoundingModeRTE* <<Execution_Mode,Execution Mode>>          | | *SPV_KHR_float_controls*
| 4468 | *RoundingModeRTZ* +
Uses the *RoundingModeRTZ* <<Execution_Mode,Execution Mode>>          | | *SPV_KHR_float_controls*

|====
--

Modify Section 2.16.1. Universal Validation Rules, adding the following sub-items to the "Entry point and execution model" item: ::
+
--
- An *OpEntryPoint* can set at most one of the *DenormFlushToZero*, *DenormPreserve*
*Execution Modes* for the given _Floating-Point Type Bit Width_.

- An *OpEntryPoint* can set at most one of the *RoundingModeRTE*, *RoundingModeRTZ*
*Execution Modes* for the given _Floating-Point Type Bit Width_.
--

Interactions with the FP Rounding Mode
--------------------------------------
The *RoundingModeRTE* and the *RoundingModeRTZ* are applied globally per entry point.
The *FPRoundingMode* is applied on per-instruction basis, which takes precedence
over the *RoundingModeRTE* and the *RoundingModeRTZ* execution modes.

Interactions with the FP Fast Math Mode
---------------------------------------
The *FPFastMathMode* decoration is limited to the *Kernel* capability.
There are no interactions with this extension.

Default execution modes
-----------------------
Default execution modes are expected to be documented by client APIs.

Issues
------
 . Do we need *DenormUnspecified*, *SignedZeroInfNanIgnore*, *RoundingModeUnspecified*?
+
--
**RESOLVED**: No. These are assumed to be the default execution modes.
This must be explicitly stated in client API execution environment specifications.
--

 . Why not reuse *FPRoundingMode*?
+
--
**RESOLVED**: We would like to have an ability to specify the rounding mode on the global scope
and also for a larger set of instructions than the *FPRoundingMode* decoration allows.
--

Revision History
----------------

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date|Author|Changes
|1|2018-09-06|Alexander Galazin|Initial revision
|========================================
